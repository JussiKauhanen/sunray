AWSTemplateFormatVersion: '2010-09-09'
Description: 'Sunray Feedback Labeling System - Anthropic Direct API'

Parameters:
  Environment:
    Type: String
    Description: Environment for deployment
    AllowedValues:
      - dev
      - tst
      - qa
      - prd
    Default: dev
    ConstraintDescription: Must be dev, tst, qa, or prd
    
  AnthropicApiKey:
    Type: String
    Description: Anthropic API Key (get from console.anthropic.com)
    NoEcho: true
    MinLength: 10
    
  ClaudeModel:
    Type: String
    Description: |
      Claude model to use via Anthropic API:
      
      Haiku - Fastest, cheapest (~$0.25/$1.25 per 1M tokens)
        Cost: $50-150 per 10K feedbacks
      
      Sonnet - Balanced performance (~$3/$15 per 1M tokens)
        Cost: $300-1,500 per 10K feedbacks
    Default: claude-3-haiku-20240307
    AllowedValues:
      - claude-3-haiku-20240307
      - claude-3-5-sonnet-20241022

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Deployment Configuration"
        Parameters:
          - Environment
      - Label:
          default: "Anthropic API Configuration"
        Parameters:
          - AnthropicApiKey
          - ClaudeModel
    ParameterLabels:
      Environment:
        default: "Environment (dev/tst/qa/prd)"
      AnthropicApiKey:
        default: "Anthropic API Key"
      ClaudeModel:
        default: "Claude Model"

Resources:
  # Secret to store Anthropic API Key
  AnthropicApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'sunray-feedback-anthropic-${Environment}-api-key'
      Description: Anthropic API Key for Claude access
      SecretString: !Sub '{"api_key":"${AnthropicApiKey}"}'
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Solution
          Value: sunray-feedback-labeling

  # S3 Bucket for feedback storage
  FeedbackBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'sunray-feedback-anthropic-${Environment}-${AWS::Region}'
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Solution
          Value: sunray-feedback-labeling
        - Key: AIProvider
          Value: anthropic-api

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'sunray-feedback-anthropic-${Environment}-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub '${FeedbackBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !GetAtt FeedbackBucket.Arn
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref AnthropicApiKeySecret

  # CloudWatch Log Group for Lambda
  FunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/sunray-feedback-anthropic-${Environment}-labeling-function'
      RetentionInDays: 7

  # The main Lambda function
  FeedbackLabelingFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'sunray-feedback-anthropic-${Environment}-labeling-function'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          OUTPUT_BUCKET: !Ref FeedbackBucket
          ENVIRONMENT: !Ref Environment
          CLAUDE_MODEL: !Ref ClaudeModel
          API_KEY_SECRET_ARN: !Ref AnthropicApiKeySecret
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Solution
          Value: sunray-feedback-labeling
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import urllib.request
          from datetime import datetime
          from urllib.parse import unquote_plus
          
          s3 = boto3.client('s3')
          secrets = boto3.client('secretsmanager')
          
          OUTPUT_BUCKET = os.environ['OUTPUT_BUCKET']
          ENVIRONMENT = os.environ['ENVIRONMENT']
          CLAUDE_MODEL = os.environ['CLAUDE_MODEL']
          API_KEY_SECRET_ARN = os.environ['API_KEY_SECRET_ARN']
          
          # Cache API key
          _api_key_cache = None
          
          def get_api_key():
              """Get Anthropic API key from Secrets Manager"""
              global _api_key_cache
              if _api_key_cache:
                  return _api_key_cache
              
              response = secrets.get_secret_value(SecretId=API_KEY_SECRET_ARN)
              secret = json.loads(response['SecretString'])
              _api_key_cache = secret['api_key']
              return _api_key_cache
          
          # Prompt template for Claude
          LABELING_PROMPT = """Analyze this customer feedback and label it accurately.

          Feedback: "{feedback_text}"
          
          You must return ONLY valid JSON (no markdown, no explanation) with these exact fields:
          - category: one of [product, service, delivery, payment, technical, general, positive_feedback]
          - sentiment: one of [positive, neutral, negative]
          - subcategory: specific issue type (e.g., "late_delivery", "poor_quality", "great_service")
          - language: detected language code (fi, en, et, lv, lt, or other)
          - priority: one of [low, medium, high]
          - summary: brief 1-sentence description in English
          - confidence: your confidence level (low, medium, high)
          
          Example output:
          {{"category":"delivery","sentiment":"negative","subcategory":"late_delivery","language":"en","priority":"high","summary":"Customer reports delayed package delivery","confidence":"high"}}
          
          Return only the JSON object, nothing else."""
          
          def invoke_claude_api(feedback_text):
              """Call Anthropic API directly"""
              api_key = get_api_key()
              prompt = LABELING_PROMPT.format(feedback_text=feedback_text)
              
              request_body = {
                  "model": CLAUDE_MODEL,
                  "max_tokens": 500,
                  "messages": [
                      {
                          "role": "user",
                          "content": prompt
                      }
                  ],
                  "temperature": 0.3
              }
              
              req = urllib.request.Request(
                  'https://api.anthropic.com/v1/messages',
                  data=json.dumps(request_body).encode('utf-8'),
                  headers={
                      'Content-Type': 'application/json',
                      'x-api-key': api_key,
                      'anthropic-version': '2023-06-01'
                  }
              )
              
              try:
                  with urllib.request.urlopen(req, timeout=30) as response:
                      response_body = json.loads(response.read().decode('utf-8'))
                      claude_response = response_body['content'][0]['text']
                      
                      # Parse Claude's JSON response
                      try:
                          labeled_data = json.loads(claude_response.strip())
                          return labeled_data
                      except json.JSONDecodeError:
                          return {
                              "error": "Failed to parse Claude response",
                              "raw_response": claude_response,
                              "category": "general",
                              "sentiment": "neutral",
                              "priority": "low"
                          }
              except Exception as e:
                  print(f"API call failed: {str(e)}")
                  raise
          
          def lambda_handler(event, context):
              """Main handler - triggered by S3 upload"""
              print(f"Environment: {ENVIRONMENT}")
              print(f"Model: {CLAUDE_MODEL}")
              print(f"Received event: {json.dumps(event)}")
              
              results = []
              
              for record in event['Records']:
                  bucket = record['s3']['bucket']['name']
                  key = unquote_plus(record['s3']['object']['key'])
                  
                  print(f"Processing: s3://{bucket}/{key}")
                  
                  try:
                      # Read the input file
                      response = s3.get_object(Bucket=bucket, Key=key)
                      file_content = response['Body'].read().decode('utf-8')
                      feedback_data = json.loads(file_content)
                      
                      # Handle both single feedback and arrays
                      feedbacks = feedback_data if isinstance(feedback_data, list) else [feedback_data]
                      
                      labeled_feedbacks = []
                      
                      for feedback in feedbacks:
                          feedback_text = feedback.get('feedback', feedback.get('message', feedback.get('text', '')))
                          
                          if not feedback_text:
                              print(f"No feedback text found in: {feedback}")
                              continue
                          
                          # Call Claude API
                          print(f"Labeling with Claude API: {feedback_text[:100]}...")
                          labeled = invoke_claude_api(feedback_text)
                          
                          # Merge original data with labels
                          result = {
                              **feedback,
                              'labels': labeled,
                              'processed_at': datetime.utcnow().isoformat(),
                              'processor': 'anthropic-api',
                              'model': CLAUDE_MODEL,
                              'environment': ENVIRONMENT
                          }
                          
                          labeled_feedbacks.append(result)
                      
                      # Write to egress folder
                      timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                      original_filename = key.split('/')[-1].replace('.json', '')
                      output_key = f"egress/{original_filename}_labeled_{timestamp}.json"
                      
                      s3.put_object(
                          Bucket=OUTPUT_BUCKET,
                          Key=output_key,
                          Body=json.dumps(labeled_feedbacks, indent=2),
                          ContentType='application/json'
                      )
                      
                      print(f"✓ Labeled data written to: s3://{OUTPUT_BUCKET}/{output_key}")
                      
                      # Move original to archive
                      archive_key = key.replace('ingress/', 'archive/')
                      s3.copy_object(
                          Bucket=OUTPUT_BUCKET,
                          CopySource={'Bucket': bucket, 'Key': key},
                          Key=archive_key
                      )
                      s3.delete_object(Bucket=bucket, Key=key)
                      
                      print(f"✓ Original moved to: s3://{OUTPUT_BUCKET}/{archive_key}")
                      
                      results.append({
                          'input': key,
                          'output': output_key,
                          'count': len(labeled_feedbacks),
                          'status': 'success'
                      })
                      
                  except Exception as e:
                      print(f"✗ Error processing {key}: {str(e)}")
                      import traceback
                      traceback.print_exc()
                      results.append({
                          'input': key,
                          'status': 'error',
                          'error': str(e)
                      })
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(results)
              }

  # Lambda Permission for S3 to invoke
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref FeedbackLabelingFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !GetAtt FeedbackBucket.Arn
      SourceAccount: !Ref AWS::AccountId

  # Custom resource to add S3 notification
  S3NotificationCustomResource:
    Type: Custom::S3BucketNotification
    Properties:
      ServiceToken: !GetAtt S3NotificationFunction.Arn
      BucketName: !Ref FeedbackBucket
      LambdaArn: !GetAtt FeedbackLabelingFunction.Arn
      NotificationId: FeedbackIngressNotification

  # Lambda to configure S3 notifications
  S3NotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'sunray-feedback-anthropic-${Environment}-s3-config'
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt S3NotificationFunctionRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          
          s3 = boto3.client('s3')
          
          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  lambda_arn = event['ResourceProperties']['LambdaArn']
                  notification_id = event['ResourceProperties']['NotificationId']
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      s3.put_bucket_notification_configuration(
                          Bucket=bucket,
                          NotificationConfiguration={
                              'LambdaFunctionConfigurations': [
                                  {
                                      'Id': notification_id,
                                      'LambdaFunctionArn': lambda_arn,
                                      'Events': ['s3:ObjectCreated:*'],
                                      'Filter': {
                                          'Key': {
                                              'FilterRules': [
                                                  {'Name': 'prefix', 'Value': 'ingress/'},
                                                  {'Name': 'suffix', 'Value': '.json'}
                                              ]
                                          }
                                      }
                                  }
                              ]
                          }
                      )
                      print(f"✓ Notification configured for bucket: {bucket}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
                  elif event['RequestType'] == 'Delete':
                      try:
                          s3.put_bucket_notification_configuration(
                              Bucket=bucket,
                              NotificationConfiguration={}
                          )
                          print(f"✓ Notification removed from bucket: {bucket}")
                      except Exception as e:
                          print(f"Note: Could not remove notification: {e}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
              except Exception as e:
                  print(f"✗ Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

  # Role for the S3 notification configuration Lambda
  S3NotificationFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3NotificationConfig
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutBucketNotification
                  - s3:GetBucketNotification
                Resource: !GetAtt FeedbackBucket.Arn

Outputs:
  StackName:
    Description: CloudFormation stack name
    Value: !Ref AWS::StackName
    
  Environment:
    Description: Deployment environment
    Value: !Ref Environment
    
  BucketName:
    Description: S3 Bucket for feedback files
    Value: !Ref FeedbackBucket
    Export:
      Name: !Sub 'sunray-feedback-anthropic-${Environment}-BucketName'
  
  IngressFolder:
    Description: Upload raw feedback JSON files here
    Value: !Sub 's3://${FeedbackBucket}/ingress/'
    
  EgressFolder:
    Description: Labeled feedback appears here
    Value: !Sub 's3://${FeedbackBucket}/egress/'
    
  ArchiveFolder:
    Description: Processed files are moved here
    Value: !Sub 's3://${FeedbackBucket}/archive/'
  
  LambdaFunctionName:
    Description: Lambda function processing the feedback
    Value: !Ref FeedbackLabelingFunction
    
  ClaudeModelUsed:
    Description: Claude model being used via Anthropic API
    Value: !Ref ClaudeModel
    
  ApiKeySecretArn:
    Description: Secrets Manager ARN containing Anthropic API key
    Value: !Ref AnthropicApiKeySecret
    
  EstimatedMonthlyCost:
    Description: Estimated cost for 10K feedbacks/month
    Value: $50-150 (Haiku) or $300-1,500 (Sonnet)
    
  CloudWatchLogGroup:
    Description: View Lambda logs here
    Value: !Sub 'https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:log-groups/log-group/$252Faws$252Flambda$252Fsunray-feedback-anthropic-${Environment}-labeling-function'
  
  S3Console:
    Description: Open S3 bucket in console
    Value: !Sub 'https://s3.console.aws.amazon.com/s3/buckets/${FeedbackBucket}?region=${AWS::Region}'
    
  HowToGetApiKey:
    Description: Get your Anthropic API key
    Value: Sign up at console.anthropic.com and create an API key
    
  TestCommand:
    Description: CLI command to test with sample file
    Value: !Sub 'aws s3 cp sample-feedback.json s3://${FeedbackBucket}/ingress/ --region ${AWS::Region}'