AWSTemplateFormatVersion: '2010-09-09'
Description: 'Sunray Feedback Labeling System - Amazon Comprehend'

Parameters:
  Environment:
    Type: String
    Description: Environment for deployment
    AllowedValues:
      - dev
      - tst
      - qa
      - prd
    Default: dev
    ConstraintDescription: Must be dev, tst, qa, or prd

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Deployment Configuration"
        Parameters:
          - Environment
    ParameterLabels:
      Environment:
        default: "Environment (dev/tst/qa/prd)"

Resources:
  # S3 Bucket for feedback storage
  FeedbackBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'sunray-feedback-comprehend-${Environment}-${AWS::Region}'
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Solution
          Value: sunray-feedback-labeling
        - Key: AIProvider
          Value: aws-comprehend

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'sunray-feedback-comprehend-${Environment}-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub '${FeedbackBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !GetAtt FeedbackBucket.Arn
        - PolicyName: ComprehendAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - comprehend:DetectSentiment
                  - comprehend:DetectDominantLanguage
                  - comprehend:BatchDetectSentiment
                  - comprehend:BatchDetectDominantLanguage
                Resource: '*'

  # CloudWatch Log Group for Lambda
  FunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/sunray-feedback-comprehend-${Environment}-labeling-function'
      RetentionInDays: 7

  # The main Lambda function
  FeedbackLabelingFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'sunray-feedback-comprehend-${Environment}-labeling-function'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          OUTPUT_BUCKET: !Ref FeedbackBucket
          ENVIRONMENT: !Ref Environment
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Solution
          Value: sunray-feedback-labeling
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from urllib.parse import unquote_plus
          
          s3 = boto3.client('s3')
          comprehend = boto3.client('comprehend')
          
          OUTPUT_BUCKET = os.environ['OUTPUT_BUCKET']
          ENVIRONMENT = os.environ['ENVIRONMENT']
          
          # Category keywords mapping
          CATEGORY_KEYWORDS = {
              'product': ['product', 'quality', 'broken', 'defective', 'item', 'poor', 'tuote'],
              'service': ['service', 'staff', 'help', 'support', 'customer', 'palvelu', 'asiakaspalvelu'],
              'delivery': ['delivery', 'shipping', 'late', 'delayed', 'arrived', 'toimitus', 'myöhässä'],
              'payment': ['payment', 'charge', 'refund', 'price', 'expensive', 'maksu', 'hinta'],
              'technical': ['error', 'bug', 'crash', 'loading', 'website', 'app', 'virhe']
          }
          
          def detect_category(text):
              """Simple keyword-based category detection"""
              text_lower = text.lower()
              
              # Count matches for each category
              scores = {}
              for category, keywords in CATEGORY_KEYWORDS.items():
                  score = sum(1 for keyword in keywords if keyword in text_lower)
                  if score > 0:
                      scores[category] = score
              
              # Return category with highest score, or 'general' if none
              if scores:
                  return max(scores.items(), key=lambda x: x[1])[0]
              
              # Check for positive feedback
              positive_words = ['great', 'good', 'excellent', 'love', 'perfect', 'hyvä', 'loistava', 'kiitos']
              if any(word in text_lower for word in positive_words):
                  return 'positive_feedback'
              
              return 'general'
          
          def detect_subcategory(text, category):
              """Simple subcategory detection"""
              text_lower = text.lower()
              
              if category == 'delivery':
                  if any(word in text_lower for word in ['late', 'delayed', 'myöhässä']):
                      return 'late_delivery'
                  if any(word in text_lower for word in ['damaged', 'broken']):
                      return 'damaged_delivery'
              elif category == 'product':
                  if any(word in text_lower for word in ['broken', 'defective', 'poor']):
                      return 'poor_quality'
              elif category == 'service':
                  if any(word in text_lower for word in ['great', 'excellent', 'good']):
                      return 'great_service'
              
              return 'general_' + category
          
          def analyze_feedback(feedback_text):
              """Analyze feedback using AWS Comprehend"""
              try:
                  # Detect sentiment
                  sentiment_response = comprehend.detect_sentiment(
                      Text=feedback_text,
                      LanguageCode='en'  # Comprehend will auto-detect if needed
                  )
                  
                  # Detect language
                  language_response = comprehend.detect_dominant_language(
                      Text=feedback_text
                  )
                  
                  sentiment = sentiment_response['Sentiment'].lower()
                  language = language_response['Languages'][0]['LanguageCode'] if language_response['Languages'] else 'unknown'
                  
                  # Detect category and subcategory
                  category = detect_category(feedback_text)
                  subcategory = detect_subcategory(feedback_text, category)
                  
                  # Determine priority based on sentiment
                  priority = 'high' if sentiment == 'negative' else 'medium' if sentiment == 'mixed' else 'low'
                  
                  # Generate summary
                  summary = f"Customer feedback with {sentiment} sentiment about {category}"
                  
                  return {
                      'category': category,
                      'sentiment': sentiment,
                      'subcategory': subcategory,
                      'language': language,
                      'priority': priority,
                      'summary': summary,
                      'confidence': 'medium',
                      'sentiment_scores': sentiment_response['SentimentScore']
                  }
                  
              except Exception as e:
                  print(f"Error analyzing feedback: {str(e)}")
                  return {
                      'category': 'general',
                      'sentiment': 'neutral',
                      'subcategory': 'unknown',
                      'language': 'unknown',
                      'priority': 'low',
                      'summary': 'Analysis failed',
                      'confidence': 'low',
                      'error': str(e)
                  }
          
          def lambda_handler(event, context):
              """Main handler - triggered by S3 upload"""
              print(f"Environment: {ENVIRONMENT}")
              print(f"Processor: AWS Comprehend")
              print(f"Received event: {json.dumps(event)}")
              
              results = []
              
              for record in event['Records']:
                  bucket = record['s3']['bucket']['name']
                  key = unquote_plus(record['s3']['object']['key'])
                  
                  print(f"Processing: s3://{bucket}/{key}")
                  
                  try:
                      # Read the input file
                      response = s3.get_object(Bucket=bucket, Key=key)
                      file_content = response['Body'].read().decode('utf-8')
                      feedback_data = json.loads(file_content)
                      
                      # Handle both single feedback and arrays
                      feedbacks = feedback_data if isinstance(feedback_data, list) else [feedback_data]
                      
                      labeled_feedbacks = []
                      
                      for feedback in feedbacks:
                          feedback_text = feedback.get('feedback', feedback.get('message', feedback.get('text', '')))
                          
                          if not feedback_text:
                              print(f"No feedback text found in: {feedback}")
                              continue
                          
                          # Analyze with Comprehend
                          print(f"Analyzing with Comprehend: {feedback_text[:100]}...")
                          labeled = analyze_feedback(feedback_text)
                          
                          # Merge original data with labels
                          result = {
                              **feedback,
                              'labels': labeled,
                              'processed_at': datetime.utcnow().isoformat(),
                              'processor': 'aws-comprehend',
                              'environment': ENVIRONMENT
                          }
                          
                          labeled_feedbacks.append(result)
                      
                      # Write to egress folder
                      timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                      original_filename = key.split('/')[-1].replace('.json', '')
                      output_key = f"egress/{original_filename}_labeled_{timestamp}.json"
                      
                      s3.put_object(
                          Bucket=OUTPUT_BUCKET,
                          Key=output_key,
                          Body=json.dumps(labeled_feedbacks, indent=2),
                          ContentType='application/json'
                      )
                      
                      print(f"✓ Labeled data written to: s3://{OUTPUT_BUCKET}/{output_key}")
                      
                      # Move original to archive
                      archive_key = key.replace('ingress/', 'archive/')
                      s3.copy_object(
                          Bucket=OUTPUT_BUCKET,
                          CopySource={'Bucket': bucket, 'Key': key},
                          Key=archive_key
                      )
                      s3.delete_object(Bucket=bucket, Key=key)
                      
                      print(f"✓ Original moved to: s3://{OUTPUT_BUCKET}/{archive_key}")
                      
                      results.append({
                          'input': key,
                          'output': output_key,
                          'count': len(labeled_feedbacks),
                          'status': 'success'
                      })
                      
                  except Exception as e:
                      print(f"✗ Error processing {key}: {str(e)}")
                      import traceback
                      traceback.print_exc()
                      results.append({
                          'input': key,
                          'status': 'error',
                          'error': str(e)
                      })
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(results)
              }

  # Lambda Permission for S3 to invoke
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref FeedbackLabelingFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !GetAtt FeedbackBucket.Arn
      SourceAccount: !Ref AWS::AccountId

  # Custom resource to add S3 notification
  S3NotificationCustomResource:
    Type: Custom::S3BucketNotification
    Properties:
      ServiceToken: !GetAtt S3NotificationFunction.Arn
      BucketName: !Ref FeedbackBucket
      LambdaArn: !GetAtt FeedbackLabelingFunction.Arn
      NotificationId: FeedbackIngressNotification

  # Lambda to configure S3 notifications
  S3NotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'sunray-feedback-comprehend-${Environment}-s3-config'
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt S3NotificationFunctionRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          
          s3 = boto3.client('s3')
          
          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  lambda_arn = event['ResourceProperties']['LambdaArn']
                  notification_id = event['ResourceProperties']['NotificationId']
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      s3.put_bucket_notification_configuration(
                          Bucket=bucket,
                          NotificationConfiguration={
                              'LambdaFunctionConfigurations': [
                                  {
                                      'Id': notification_id,
                                      'LambdaFunctionArn': lambda_arn,
                                      'Events': ['s3:ObjectCreated:*'],
                                      'Filter': {
                                          'Key': {
                                              'FilterRules': [
                                                  {'Name': 'prefix', 'Value': 'ingress/'},
                                                  {'Name': 'suffix', 'Value': '.json'}
                                              ]
                                          }
                                      }
                                  }
                              ]
                          }
                      )
                      print(f"✓ Notification configured for bucket: {bucket}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
                  elif event['RequestType'] == 'Delete':
                      try:
                          s3.put_bucket_notification_configuration(
                              Bucket=bucket,
                              NotificationConfiguration={}
                          )
                          print(f"✓ Notification removed from bucket: {bucket}")
                      except Exception as e:
                          print(f"Note: Could not remove notification: {e}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
              except Exception as e:
                  print(f"✗ Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

  # Role for the S3 notification configuration Lambda
  S3NotificationFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3NotificationConfig
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutBucketNotification
                  - s3:GetBucketNotification
                Resource: !GetAtt FeedbackBucket.Arn

Outputs:
  StackName:
    Description: CloudFormation stack name
    Value: !Ref AWS::StackName
    
  Environment:
    Description: Deployment environment
    Value: !Ref Environment
    
  BucketName:
    Description: S3 Bucket for feedback files
    Value: !Ref FeedbackBucket
    Export:
      Name: !Sub 'sunray-feedback-comprehend-${Environment}-BucketName'
  
  IngressFolder:
    Description: Upload raw feedback JSON files here
    Value: !Sub 's3://${FeedbackBucket}/ingress/'
    
  EgressFolder:
    Description: Labeled feedback appears here
    Value: !Sub 's3://${FeedbackBucket}/egress/'
    
  ArchiveFolder:
    Description: Processed files are moved here
    Value: !Sub 's3://${FeedbackBucket}/archive/'
  
  LambdaFunctionName:
    Description: Lambda function processing the feedback
    Value: !Ref FeedbackLabelingFunction
    
  ProcessorType:
    Description: AI processor being used
    Value: AWS Comprehend (keyword-based + sentiment analysis)
    
  EstimatedMonthlyCost:
    Description: Estimated cost for 10K feedbacks/month
    Value: $10-30 (very cost-effective)
    
  CloudWatchLogGroup:
    Description: View Lambda logs here
    Value: !Sub 'https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:log-groups/log-group/$252Faws$252Flambda$252Fsunray-feedback-comprehend-${Environment}-labeling-function'
  
  S3Console:
    Description: Open S3 bucket in console
    Value: !Sub 'https://s3.console.aws.amazon.com/s3/buckets/${FeedbackBucket}?region=${AWS::Region}'
    
  TestCommand:
    Description: CLI command to test with sample file
    Value: !Sub 'aws s3 cp sample-feedback.json s3://${FeedbackBucket}/ingress/ --region ${AWS::Region}'